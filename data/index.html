<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control de Tarjetas RFID - Tiempo Real</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        h1 { color: #0056b3; text-align: center; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; background-color: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        th, td { text-align: center; padding: 12px 15px; border-bottom: 1px solid #ddd; }
        th { background-color: #007bff; color: white; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        tr:hover { background-color: #ddd; }
        #status { text-align: center; margin-bottom: 15px; font-weight: bold; color: #555; }

        /* Estilo para tarjetas inactivas */
        .inactive-card {
            background-color: #7aaac6 !important;
            color: #000;
            font-style: italic;
        }
        .inactive-card:hover {
            background-color: #dee2e6; /* Un gris un poco más oscuro al pasar el mouse */
        }
        .inactive-card td {
            color: inherit;
        }

        /* Estilo para tarjetas históricas (liberadas) */
        .historical-card {
            background-color: #e0e0e0 !important; /* Un gris más claro para diferenciarlas */
            color: #666;
            font-style: italic;
            opacity: 0.8;
        }
        .historical-card:hover {
            background-color: #d0d0d0;
        }

        /* Estilo del botón de eliminar */
        .delete-btn {
            background-color: #dc3545; /* Rojo */
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
            margin-right: 5px; /* Espacio entre botones */
        }
        .delete-btn:hover {
            background-color: #c82333; /* Rojo más oscuro al pasar el mouse */
        }

        /* Estilo del botón de liberar */
        .liberate-btn {
            background-color: #28a745; /* Verde */
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }
        .liberate-btn:hover {
            background-color: #218838; /* Verde más oscuro al pasar el mouse */
        }
        .liberate-btn:disabled {
            background-color: #6c757d; /* Gris para deshabilitado */
            cursor: not-allowed;
        }

        @media (max-width: 600px) {
            table, thead, tbody, th, td, tr { display: block; }
            thead tr { position: absolute; top: -9999px; left: -9999px; }
            tr { border: 1px solid #ccc; margin-bottom: 10px; }
            td { border: none; border-bottom: 1px solid #eee; position: relative; padding-left: 50%; text-align: right; }
            td:before { position: absolute; top: 6px; left: 6px; width: 45%; padding-right: 10px; white-space: nowrap; content: attr(data-label); font-weight: bold; text-align: left; }
            
            td[data-label="Acciones"] {
                text-align: left;
                padding-left: 15px;
            }
            td[data-label="Acciones"]:before {
                content: '';
            }
        }
    </style>
</head>
<body>
    <h1>Control de Tarjetas RFID - Tiempo Real</h1>
    <div id="status">Conectando al ESP32...</div>
    <table>
        <thead>
            <tr>
                <th>UID Tarjeta</th>
                <th>Grupo</th>
                <th>Tiempo Total</th>
                <th>Acciones</th>
            </tr>
        </thead>
        <tbody id="cardTableBody">
            </tbody>
    </table>

    <script>
        var gateway = `ws://${window.location.hostname}/ws`;
        var websocket;
        
        // tarjetasData ahora es un ARRAY para mantener múltiples entradas para el mismo UID
        // Cada objeto dentro del array representará una "sesión" de una tarjeta
        var tarjetasData = []; 
        
        var lastEsp32Millis = 0;
        var lastClientTimestamp = 0;

        function formatMillisToMMSS(millis) {
            if (millis < 0) millis = 0;
            let seconds = Math.floor(millis / 1000);
            let minutes = Math.floor(seconds / 60);
            seconds %= 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function initWebSocket() {
            console.log('Intentando abrir conexión WebSocket...');
            websocket = new WebSocket(gateway);
            websocket.onopen = onOpen;
            websocket.onclose = onClose;
            websocket.onmessage = onMessage;
        }

        function onOpen(event) {
            console.log('Conexión WebSocket abierta');
            document.getElementById('status').innerText = 'Conectado al ESP32. Esperando datos...';
        }

        function onClose(event) {
            console.log('Conexión WebSocket cerrada. Reintentando en 2 segundos...');
            document.getElementById('status').innerText = 'Desconectado. Reconectando...';
            setTimeout(initWebSocket, 2000);
        }

        function onMessage(event) {
            console.log('Mensaje WebSocket recibido:', event.data);
            document.getElementById('status').innerText = 'Datos actualizados.';
            try {
                const receivedData = JSON.parse(event.data);
                
                lastEsp32Millis = receivedData.timestampEsp32;
                lastClientTimestamp = Date.now();
                
                // Paso 1: Marcar todas las tarjetas activas LOCALES como NO presentes en el ESP32
                // Esto es para detectar cuáles se eliminaron del ESP32 o si son nuevas sesiones
                tarjetasData.forEach(card => {
                    // Solo marcar si no fue liberada o eliminada localmente (ya que esas persisten intencionalmente)
                    if (!card.isLocallyLiberated && !card.isLocallyDeleted) { 
                        card.isPresentInEsp32 = false;
                    }
                });

                // Paso 2: Actualizar o añadir tarjetas de la respuesta del ESP32
                if (receivedData.tarjetas) {
                    receivedData.tarjetas.forEach(receivedCard => {
                        let found = false;
                        // Buscar una entrada existente que coincida por UID y Grupo
                        for (let i = 0; i < tarjetasData.length; i++) {
                            const localCard = tarjetasData[i];
                            if (localCard.uid === receivedCard.uid && localCard.grupo === receivedCard.grupo) {
                                // Actualizar la tarjeta existente
                                Object.assign(localCard, receivedCard); // Copia todas las propiedades
                                localCard.isPresentInEsp32 = true; // Está presente en la respuesta del ESP32
                                localCard.isLocallyLiberated = false; // Ya no está "liberada" localmente (se re-activó)
                                localCard.isLocallyDeleted = false; // Ya no está "eliminada" localmente
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            // Si no se encontró, es una nueva sesión (o una tarjeta que fue liberada y re-leída)
                            receivedCard.isPresentInEsp32 = true;
                            receivedCard.isLocallyLiberated = false;
                            receivedCard.isLocallyDeleted = false;
                            tarjetasData.push(receivedCard);
                        }
                    });
                }
                
                // Paso 3: Filtrar el array para eliminar entradas que el ESP32 ya no reporta
                // y que NO fueron marcadas para persistir localmente (liberadas/eliminadas históricamente)
                tarjetasData = tarjetasData.filter(card => 
                    card.isPresentInEsp32 || card.isLocallyLiberated || card.isLocallyDeleted
                );

                updateTableDisplay();
            } catch (e) {
                console.error("Error al parsear JSON:", e);
            }
        }

        function updateTableDisplay() {
            const tableBody = document.getElementById('cardTableBody');
            tableBody.innerHTML = '';

            // Ordenar por grupo para consistencia visual
            const sortedTarjetas = [...tarjetasData].sort((a, b) => {
                const groupA = parseInt(a.grupo.replace('Grupo ', ''));
                const groupB = parseInt(b.grupo.replace('Grupo ', ''));
                // Si los grupos son iguales, ordenar por UID (o algún otro identificador secundario)
                if (groupA === groupB) {
                    return a.uid.localeCompare(b.uid);
                }
                return groupA - groupB;
            });


            if (sortedTarjetas.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center;">No hay tarjetas en el historial.</td></tr>';
                return;
            }

            sortedTarjetas.forEach((tarjeta, index) => {
                const row = tableBody.insertRow();
                // Si la tarjeta no está activa O SI HA SIDO LIBERADA LOCALMENTE O ELIMINADA LOCALMENTE
                if (!tarjeta.isActive) { // Siempre inactiva si el ESP32 la marcó así
                    row.classList.add('inactive-card');
                }
                if (tarjeta.isLocallyLiberated) { // Solo para "Liberadas" que persisten
                    row.classList.add('historical-card'); 
                }


                row.insertCell().setAttribute('data-label', 'UID Tarjeta');
                row.cells[0].innerText = tarjeta.uid;
                row.insertCell().setAttribute('data-label', 'Grupo');
                row.cells[1].innerText = tarjeta.grupo;
                
                const timeCell = row.insertCell();
                timeCell.setAttribute('data-label', 'Tiempo Total');
                // ID único por UID y Grupo para evitar conflictos si hay el mismo UID en diferentes grupos
                timeCell.id = `time-${tarjeta.uid}-${tarjeta.grupo.replace('Grupo ', '')}`; 

                // El tiempo solo se actualiza si está activa Y no ha sido liberada localmente
                if (tarjeta.isActive && !tarjeta.isLocallyLiberated) { 
                    timeCell.dataset.startTime = tarjeta.startTime;
                    timeCell.dataset.isActive = 'true';
                    const offset = lastClientTimestamp - lastEsp32Millis;
                    const elapsedMillis = Date.now() - (tarjeta.startTime + offset);
                    timeCell.innerText = formatMillisToMMSS(elapsedMillis);
                } else {
                    timeCell.dataset.isActive = 'false';
                    timeCell.innerText = tarjeta.tiempoTotalFormatted;
                }

                // Celda para acciones
                const actionsCell = row.insertCell();
                actionsCell.setAttribute('data-label', 'Acciones');

                // Botón Eliminar
                const deleteButton = document.createElement('button');
                deleteButton.classList.add('delete-btn');
                deleteButton.innerText = 'Eliminar';
                deleteButton.dataset.uid = tarjeta.uid;
                deleteButton.dataset.grupo = tarjeta.grupo; // Pasar el grupo para identificar la sesión
                deleteButton.onclick = function() {
                    if (confirm(`¿Estás seguro de que quieres eliminar la sesión de la tarjeta ${this.dataset.uid} del ${this.dataset.grupo} de la tabla?`)) {
                        // Envía la acción "delete" al ESP32 para eliminarla del microcontrolador
                        sendCardAction("delete", this.dataset.uid);
                        
                        // Eliminar el registro del array local inmediatamente
                        tarjetasData = tarjetasData.filter(c => 
                            !(c.uid === this.dataset.uid && c.grupo === this.dataset.grupo)
                        );
                        updateTableDisplay(); // Volver a renderizar la tabla sin este registro
                    }
                };
                // El botón eliminar está disponible si NO ha sido liberada localmente
                deleteButton.disabled = tarjeta.isLocallyLiberated || false; 
                actionsCell.appendChild(deleteButton);

                // Botón Liberar
                const liberateButton = document.createElement('button');
                liberateButton.classList.add('liberate-btn');
                liberateButton.innerText = 'Liberar';
                liberateButton.dataset.uid = tarjeta.uid;
                liberateButton.dataset.grupo = tarjeta.grupo; // Pasar el grupo para identificar la sesión
                liberateButton.onclick = function() {
                    if (confirm(`¿Estás seguro de que quieres liberar la tarjeta ${this.dataset.uid} del ${this.dataset.grupo} para un nuevo uso? Su registro actual permanecerá visible como historial.`)) {
                        sendCardAction("delete", this.dataset.uid); // <--- SIEMPRE se envía "delete" al ESP32
                        
                        // Marca la tarjeta localmente como "liberada" para deshabilitar botones y cambiar estilo
                        const cardIndex = tarjetasData.findIndex(c => c.uid === this.dataset.uid && c.grupo === this.dataset.grupo);
                        if (cardIndex !== -1) {
                            tarjetasData[cardIndex].isLocallyLiberated = true;
                            tarjetasData[cardIndex].isActive = false; // Asegurar que no esté activa visualmente
                        }
                        updateTableDisplay(); // Volver a renderizar para actualizar el estado del botón
                    }
                };
                // El botón "Liberar" se deshabilita si la tarjeta está activa o si ya fue liberada localmente
                liberateButton.disabled = tarjeta.isActive || tarjeta.isLocallyLiberated; 
                actionsCell.appendChild(liberateButton);
            });
        }

        // Función unificada para enviar acciones al ESP32
        function sendCardAction(action, uid) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const message = JSON.stringify({ action: action, uid: uid });
                websocket.send(message);
                console.log(`Solicitud de acción "${action}" enviada para UID: ${uid}`);
            } else {
                console.error("WebSocket no está conectado o listo para enviar.");
                document.getElementById('status').innerText = `Error: WebSocket no conectado. No se pudo ${action}.`;
            }
        }

        // Temporizador para actualizar los tiempos de las tarjetas activas cada 1 segundo
        setInterval(() => {
            // Recorrer el array de tarjetasData
            tarjetasData.forEach(tarjeta => {
                // Solo actualizar si la tarjeta está activa Y no ha sido liberada localmente
                if (tarjeta.isActive && !tarjeta.isLocallyLiberated) { 
                    // Asegurarse de que el ID del elemento coincida con el generado en updateTableDisplay
                    const timeCell = document.getElementById(`time-${tarjeta.uid}-${tarjeta.grupo.replace('Grupo ', '')}`);
                    if (timeCell && timeCell.dataset.isActive === 'true') {
                        const startTimeEsp32 = parseInt(timeCell.dataset.startTime);
                        
                        const offset = lastClientTimestamp - lastEsp32Millis;
                        const currentElapsedMillis = Date.now() - (startTimeEsp32 + offset);

                        timeCell.innerText = formatMillisToMMSS(currentElapsedMillis);
                    }
                }
            });
        }, 1000);

        window.addEventListener('load', initWebSocket, false);
    </script>
</body>
</html>